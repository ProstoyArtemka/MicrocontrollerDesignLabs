
.org 0x0000
	rjmp start

start:
	ldi r16, -10 ; Входное R1
	ldi r17, -64 ; Входное R2

	ldi r18, 5 ; I - 5

	; Возведение R1 в куб
	
	muls  r16, r16 ; r16^2

	tst r16 ; Проверяем r16
	brpl skip_negative ; Если r16 положительное, то можно просто возводить в степень


	
	ldi r19, -1 ; Запоминаем что r16 было негативным
	neg r16 ; Инвертируем r16



skip_negative:

	mov r20, r0 ; младший байт r16^2
	mov r21, r1 ; старший байт r16^2

	dec r16 ; Отнимаем от r16 единичку, т.к. одно из слагаемых уже лежит в r0:r1

	breq cycle

multiplication:
	
	add r0, r20 ; Добавить младший байт
	adc r1, r21 ; Добавить старший байт и флаг C из предыдущей операции

	dec r16
	brne multiplication ; Если при декременте r16 он не обнулился, повторяем цикл

	; Конец возведения в степень

	mov r20, r0 ; Переносим младший байт ответа
	mov r21, r1 ; Переносим старший байт ответа

cycle:

	clt ; Чистим регистр T (который отвечает за инверсию результата деления)
	tst r19 ; Смотрим был ли куб отрицательным

	brpl cube_was_positive ; Пропускаем установку флага если куб был положительным

	set ; Ставим 1 в регистр T если r16 всё таки был отрицательным

cube_was_positive:

	clr r0
	clr r1

	; Считаем R2 + 4 * i

	ldi r30, 4 ; 4 для умножения
	muls r18, r30 ; r0 = 4 * i

	clr r30 ; 0 Для сложения ниже
	tst r17 ; Проверяем r17 на отрицательность

	brpl skip_to_addition ; Если r17 положительный, то число 100% будет положительное

	ldi r30, 0xFF ; Если r17 отрицательный, то старший байт 16 битного числа должен начинаться с FF

skip_to_addition:

	add r0, r17 ; r0 = (4 * i) + R2

	; Если r30 равно FF, тоесть R2 был отрицательным при вводе, мы добавляем сюда FF и C
	; Т.е. если в предудыщем этапе получится положительно число, произойдёт переполнение регистра
	; Следовательно Carry станет 1 и в результате старший байт делителя будет 0, т.е. число положительное
	; Если же в предыдущем этапе получится отрицательное число, то C станет 0, следовательно старший байт начнётся с FF и будет означать что 16 битное число r0:r1 является отрицательным
	adc r1, r30 ; r0:r1 = (4 * i) + R2 

	mov r2, r0 ; Переносим младший байт делителя во временный регистр, чтобы сделать операцию or и не испортить регистр r0 который ещё пригодится

	or r2, r1 ; Применяем OR к r0:r1, в Z попадёт 1 только если оба регистра равны нулю
	breq skip_division ; Если делитель равен нулю, то делить не круто

	tst r1 ; Проверка делителя на отрицательность
	brpl skip_div_inversion ; Если делитель положительный то идём дальше

	tst r19 ; Проверяем регистр который запоминает отрицательное ли делимое
	brmi clear_t ; Если и делимое и делитель отрицательные, то можно просто инвертировать делитель и очистить регистр T
	; Если только делитель отрицательный, инвертируем делитель и ставим T

	set ; Ставим T

	rjmp divider_inversion ; Прыгаем на инверсию делителя

clear_t:

	clt ; Очищаем T

divider_inversion:

	com r0 ; Инвертируем делитель (младший байт)
	com r1 ; Инвертируем делитель (страший байт)

	ldi r30, 1 ; 1 для сложения
	clr r2 ; 0 для сложения

	add r0, r30 ; Добавляем 1, так как после инвертирования 1 теряется
	adc r1, r2 ; Добавляем C, если при прошлом сложении мы вышли за 8 бит

skip_div_inversion:

	mov r22, r0 ; Младший байт делителя
	mov r23, r1 ; Старший байт делителя

	; Деление 

	mov r24, r20 ; Копируем R1^3 для деления (младший байт)
	mov r25, r21 ; Копируем R1^3 для деления (старший байт)

	clr r26
	clr r27

division:
	
	cp r24, r22 ; Сравниваем младший байт делимого и делителя (Эта инструкция ещё и устанавливает бит C, так что его можно применять дальше)
	cpc r25, r23 ; Сравнениваем страший байт делимого и делителя (Вместе с битом C, результат будет считаться как r21 - r25 - C)

	brcs result_division ; Если делимое меньше делителя, то можно прыгнуть к результату

	sub r24, r22 ; Отнимаем делитель из делимого (младший байт)
	sbc r25, r23 ; Отнимаем делитель из делимого (старший байт и C)

	adiw r26, 1 ; Увеличиваем ответ на 1

	rjmp division

result_division:
	
	brtc skip_division_inversion ; Если флаг инверсии не стоит, то пропускаем инверсию слагаемого 
	
	com r26 ; Инвертируем слагаемое (младший байт)
	com r27 ; Инвертируем слагаемое (страший байт)

	ldi r30, 1 ; 1 для сложения
	clr r2 ; 0 для сложения

	add r26, r30 ; Добавляем 1 к младшему байту из-за инверсии
	adc r27, r2 ; Добавляем C если вышли за 8 бит

skip_division_inversion:

	add r28, r26 ; Складываем результат деления к r28:r29 (младший байт)
	adc r29, r27 ; Складываем результат деления к r28:r29 (старший байт)

skip_division:
	
	dec r18

	clr r30 ; 0 для сравнения
	cp r18, r30 ; Сравниваем I и 1

	brne cycle ; Если I != 1 то продолжаем

	nop